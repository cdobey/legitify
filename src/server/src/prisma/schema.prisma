datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_CONNECTION_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-arm64-openssl-3.0.x"]
}

model User {
  id                 String      @id @default(uuid())
  username           String      @unique
  email              String      @unique
  firstName          String?
  lastName           String?
  country            String?
  role               Role
  orgName            OrgName
  profilePictureUrl  String?    
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
  
  twoFactorEnabled   Boolean     @default(false)
  twoFactorSecret    String?

  // Relations
  issuedCredentials  Credential[] @relation("Issuer")
  heldCredentials    Credential[] @relation("Holder")
  requests           Request[]    @relation("Requester")
  ownedIssuers       Issuer[]     @relation("IssuerOwner")
  sentJoinRequests   IssuerJoinRequest[] @relation("IssuerJoinRequester")
  
  // Issuer memberships
  issuerMemberships  IssuerMember[] @relation("IssuerMember")
  
  // Issuer affiliations for holders
  issuerAffiliations IssuerAffiliation[] @relation("HolderAffiliation")
}

model Issuer {
  id           String      @id @default(uuid())
  name         String
  shorthand    String      // (e.g., DCU)
  description  String?
  logoUrl      String?
  ownerId      String
  issuerType   String      // Type of issuer (academic, professional, etc.)
  country      String?
  address      String?
  website      String?     // Official website URL
  foundedYear  Int?
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  // Relations
  owner        User              @relation("IssuerOwner", fields: [ownerId], references: [id])
  joinRequests IssuerJoinRequest[] @relation("IssuerJoinTarget")
  credentials  Credential[]      @relation("CredentialIssuer")
  
  // Issuer members relationship
  members      IssuerMember[]    @relation("IssuerMembers")
  
  // Holder affiliations relationship
  affiliations IssuerAffiliation[] @relation("IssuerAffiliations")

  @@unique([name, ownerId])
}

// Issuer Members model
model IssuerMember {
  id             String          @id @default(uuid())
  userId         String
  issuerId       String
  role           String          @default("admin")
  status         MembershipStatus @default(pending)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  // Relations
  user           User            @relation("IssuerMember", fields: [userId], references: [id])
  issuer         Issuer          @relation("IssuerMembers", fields: [issuerId], references: [id])

  @@unique([userId, issuerId])
}

// Holder-Issuer affiliations
model IssuerAffiliation {
  id             String            @id @default(uuid())
  userId         String
  issuerId       String
  status         AffiliationStatus @default(pending)
  initiatedBy    String?           @default("holder") // "holder" or "issuer"
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  // Relations
  holder         User              @relation("HolderAffiliation", fields: [userId], references: [id])
  issuer         Issuer            @relation("IssuerAffiliations", fields: [issuerId], references: [id])

  @@unique([userId, issuerId])
}

// Credential model
model Credential {
  id               String           @id @default(uuid())
  docId            String           @unique
  docHash          String
  type             String           // Type of credential (credential, certificate, badge, etc.)
  holderId         String
  issuerId         String
  issuerOrgId      String
  fileData         Bytes?           // Store credential data as binary
  status           CredentialStatus @default(issued)
  title            String
  description      String?
  ledgerTimestamp  String?          // Timestamp from the blockchain
  achievementDate  DateTime?
  expirationDate   DateTime?        // Optional
  programLength    String?          // Length of the program (e.g., "4 years")
  domain           String?          // Field or area of the credential
  
  // JSON field for storing custom attributes
  attributes       Json?            // Stores the dynamic attributes as JSON
  
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  // Relations
  issuer          User             @relation("Issuer", fields: [issuerId], references: [id])
  holder          User             @relation("Holder", fields: [holderId], references: [id])
  issuerOrg       Issuer           @relation("CredentialIssuer", fields: [issuerOrgId], references: [id])
  requests        Request[]        @relation("Credential")
}

model Request {
  id             String        @id @default(uuid())
  requesterId    String
  credentialId   String
  status         RequestStatus @default(pending)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // Relations
  requester      User          @relation("Requester", fields: [requesterId], references: [id])
  credential     Credential    @relation("Credential", fields: [credentialId], references: [id])
}

model WalletIdentity {
  label         String        @id
  orgName       OrgName
  type          String        // e.g., "X.509"
  certificate   String        @db.Text
  privateKey    String        @db.Text
  mspId         String
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@unique([label, orgName])
}

enum Role {
  issuer
  holder
  verifier
}

enum OrgName {
  orgissuer
  orgholder
  orgverifier
}

enum CredentialStatus {
  issued
  accepted
  denied
}

enum RequestStatus {
  pending
  granted
  denied
}

enum AffiliationStatus {
  pending
  active
  rejected
}

enum MembershipStatus {
  pending
  active
  rejected
}

model IssuerJoinRequest {
  id             String    @id @default(uuid())
  requesterId    String
  issuerId       String
  status         String    @default("pending") // pending, approved, rejected
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  requester      User      @relation("IssuerJoinRequester", fields: [requesterId], references: [id])
  issuer         Issuer    @relation("IssuerJoinTarget", fields: [issuerId], references: [id])
}
