image: node:18-bullseye

stages:
  - test
  - deploy
  - post-deploy

variables:
  SERVER_PID_FILE: '/tmp/server.pid'
  SERVER_STARTUP_TIMEOUT: 120
  TEST_FLOW_TIMEOUT: 300
  SKIP_TESTS: 'true'
  SKIP_DEPLOY: 'true'
  SKIP_DB_INIT: 'false'

test_flow:
  stage: test
  rules:
    - if: $SKIP_TESTS == "true"
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "master"
  tags:
    - shell
  before_script:
    - |
      # Add disk usage monitoring
      echo "üíæ Checking disk space before job starts:"
      df -h /
      docker system df || echo "Docker not running or command failed"

      # For Amazon Linux - install required packages if needed
      # Using yum instead of apt-get
      if ! command -v jq &> /dev/null || ! command -v docker &> /dev/null; then
        echo "Installing required packages..."
        sudo yum update -y
        sudo yum install -y jq docker golang git curl
        # Clean yum cache
        sudo yum clean all
      fi

      # Just verify versions of pre-installed tools
      node --version
      npm --version
      docker --version
      go version || echo "Go may not be installed"

    - cd $CI_PROJECT_DIR
    - git clean -fdx
    - sudo chown -R gitlab-runner:gitlab-runner .

  script:
    - cd $CI_PROJECT_DIR/src/server
    - npm install
    - npm ci

    # Prepare Fabric environment
    - cd $CI_PROJECT_DIR/src/ledger
    - export ARCH=amd64
    - export FABRIC_PATH=$PWD
    - export PATH=$PATH:$FABRIC_PATH/bin

    # Restore cached binaries if they exist
    - |
      if [ ! -d "$CI_PROJECT_DIR/src/ledger/bin" ] || [ ! -f "$CI_PROJECT_DIR/src/ledger/bin/peer" ]; then
        echo "Fabric binaries not found in cache, downloading..."
        
        chmod +x $CI_PROJECT_DIR/src/ledger/setup-fabric.sh
        $CI_PROJECT_DIR/src/ledger/setup-fabric.sh --fabric-version 2.5.10 --ca-version 1.5.13 binary
        
        chmod +x bin/*
      else
        echo "Using cached Fabric binaries"
      fi

    # Prepare chaincode
    - cd chaincode/degreeChaincode
    - GO111MODULE=on go mod vendor

    # Start the network and test
    - cd $CI_PROJECT_DIR/src/ledger/legitify-network
    - bash scripts/startNetwork.sh
    - bash scripts/testDegreeChaincode.sh

  after_script:
    - |
      echo "Starting cleanup..."
      set +e  # Continue on errors during cleanup

      kill_process_tree() {
        local pid=$1
        if [ -n "$pid" ]; then
          children=$(pgrep -P $pid)
          for child in $children; do
            kill_process_tree $child
          done
          kill -9 $pid 2>/dev/null || true
        fi
      }

      # Stop backend server
      if [ -f "$SERVER_PID_FILE" ]; then
        SERVER_PID=$(cat "$SERVER_PID_FILE")
        echo "Stopping server with PID $SERVER_PID"
        kill_process_tree $SERVER_PID
        rm -f "$SERVER_PID_FILE"
      fi

      # Clean up database and wallet
      cd $CI_PROJECT_DIR/src/server || true
      docker-compose down -v || true
      sudo rm -rf pgdata src/wallet/* || true

      # Tear down Fabric network
      cd $CI_PROJECT_DIR/src/ledger/legitify-network || true
      ./network.sh down || true
      docker system prune -af --volumes || true

      # Clean npm cache
      npm cache clean --force || true

      # Reset permissions
      cd $CI_PROJECT_DIR || true
      sudo chown -R gitlab-runner:gitlab-runner . || true
      sudo find . -type d -exec chmod 755 {} + || true
      sudo find . -type f -exec chmod 644 {} + || true

      # Show disk space after cleanup
      echo "üíæ Checking disk space after cleanup:"
      df -h /

      echo "Cleanup completed"

  cache:
    key: ${CI_COMMIT_REF_SLUG}-fabric-binaries
    paths:
      - src/server/node_modules/
      - src/ledger/bin/
      - ~/.npm/
    policy: pull-push

deploy_all:
  stage: deploy
  tags:
    - shell
  needs:
    - job: test_flow
      optional: true
  rules:
    - if: $SKIP_DEPLOY == "true"
      when: never
    - if: $SKIP_TESTS == "true" || $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
      when: manual
  variables:
    # Ledger deployment variables
    EC2_HOST: 'network.legitifyapp.com'
    EC2_USER: 'ec2-user'
    SSH_KEY_FILE: '/tmp/aws_ssh_key'
    SOURCE_DIR: '$CI_PROJECT_DIR/src/ledger'
    # Docker image variables for backend and client
    BACKEND_IMAGE_NAME: '${DOCKER_USERNAME}/legitify-project'
    BACKEND_IMAGE_NAME_PODGE: '${DOCKER_USERNAME_PODGE}/legitify-project'
    BACKEND_IMAGE_TAG: 'backend'
    CLIENT_IMAGE_NAME: '${DOCKER_USERNAME}/legitify-project'
    CLIENT_IMAGE_NAME_PODGE: '${DOCKER_USERNAME_PODGE}/legitify-project'
    CLIENT_IMAGE_TAG: 'client'
  before_script: |
    # Add disk usage monitoring
    echo "üíæ Checking disk space before job starts:"
    df -h /
    docker system df || echo "Docker not running or command failed"

    # For Amazon Linux - ensure docker is running
    sudo systemctl start docker || sudo service docker start || echo "Could not start Docker service"

    echo "$AWS_PRIVATE_KEY_B64" | base64 -d > $SSH_KEY_FILE
    chmod 600 $SSH_KEY_FILE
    docker login -u "$DOCKER_USERNAME" -p "$DOCKER_PASSWORD"
    echo "Logged in as Docker user: $DOCKER_USERNAME"
  script: |
    # Step 1: Deploy Ledger
    echo "Starting ledger deployment..."
    cd $CI_PROJECT_DIR/src/ledger/legitify-network/scripts
    chmod +x deploy-ledger.sh
    ./deploy-ledger.sh
    echo "Ledger deployment completed"

    # Step 2: Deploy Backend to Render
    echo "Starting backend deployment..."
    cd $CI_PROJECT_DIR/src/server

    # Build the Docker image (without DB initialization)
    echo "Building backend Docker image..."
    docker build --platform linux/amd64 \
      --build-arg FABRIC_CONNECTION=${FABRIC_CONNECTION:-network.legitifyapp.com} \
      --build-arg RESOURCE_SERVER_PORT=${RESOURCE_SERVER_PORT:-8080} \
      -t $BACKEND_IMAGE_NAME:$BACKEND_IMAGE_TAG .

    # Push to first Docker Hub account
    docker push $BACKEND_IMAGE_NAME:$BACKEND_IMAGE_TAG

    # Push to second Docker Hub account (Podge)
    docker logout
    docker login -u "$DOCKER_USERNAME_PODGE" -p "$DOCKER_PASSWORD_PODGE"
    echo "Logged in as second Docker user: $DOCKER_USERNAME_PODGE"
    docker build --platform linux/amd64 \
      --build-arg FABRIC_CONNECTION=${FABRIC_CONNECTION:-network.legitifyapp.com} \
      --build-arg RESOURCE_SERVER_PORT=${RESOURCE_SERVER_PORT:-8080} \
      -t $BACKEND_IMAGE_NAME_PODGE:$BACKEND_IMAGE_TAG .
    docker push $BACKEND_IMAGE_NAME_PODGE:$BACKEND_IMAGE_TAG

    # Switch back to first account for the rest of the pipeline
    docker logout
    docker login -u "$DOCKER_USERNAME" -p "$DOCKER_PASSWORD"

    # Trigger both Render deployments for backend
    echo "Triggering Render deployments via webhooks..."
    curl -X POST "$RENDER_DEPLOY_HOOK"
    echo "Triggering Podge's Render deployment via webhook..."
    curl -X POST "$RENDER_DEPLOY_HOOK_PODGE"
    echo "Waiting for backend deployments to complete..."
    sleep 120

    # Step 3: Deploy Client to Render
    echo "Starting client deployment..."
    cd $CI_PROJECT_DIR/src/client/legitify-project

    # Build with credentials passed as build args (more secure than env file)
    # Using --build-arg keeps the values out of the image history
    echo "Building client Docker image..."
    docker build --platform linux/amd64 \
      --build-arg VITE_SUPABASE_URL=${VITE_SUPABASE_URL} \
      --build-arg VITE_SUPABASE_ANON_KEY=${VITE_SUPABASE_ANON_KEY} \
      --build-arg VITE_API_URL=${VITE_API_URL} \
      -t $CLIENT_IMAGE_NAME:$CLIENT_IMAGE_TAG .

    # Push to first Docker Hub account
    docker push $CLIENT_IMAGE_NAME:$CLIENT_IMAGE_TAG

    # Push to second Docker Hub account (Podge)
    docker logout
    docker login -u "$DOCKER_USERNAME_PODGE" -p "$DOCKER_PASSWORD_PODGE"
    docker build --platform linux/amd64 \
      --build-arg VITE_SUPABASE_URL=${VITE_SUPABASE_URL} \
      --build-arg VITE_SUPABASE_ANON_KEY=${VITE_SUPABASE_ANON_KEY} \
      --build-arg VITE_API_URL=${VITE_API_URL} \
      -t $CLIENT_IMAGE_NAME_PODGE:$CLIENT_IMAGE_TAG .
    docker push $CLIENT_IMAGE_NAME_PODGE:$CLIENT_IMAGE_TAG

    # Switch back to first account
    docker logout
    docker login -u "$DOCKER_USERNAME" -p "$DOCKER_PASSWORD"

    # Trigger both Render deployments for client
    echo "Triggering Render client deployments via webhooks..."
    curl -X POST "$RENDER_CLIENT_DEPLOY_HOOK"
    echo "Triggering Podge's Render client deployment via webhook..."
    curl -X POST "$RENDER_CLIENT_DEPLOY_HOOK_PODGE"
    echo "Full deployment process completed successfully"
  after_script: |
    # Clean up key after use for security
    rm -f $SSH_KEY_FILE

    # Aggressively prune Docker resources
    echo "Cleaning up Docker resources after deployment build..."
    docker system prune -af --volumes || echo "Docker prune failed, continuing..."

    # Clean npm cache
    npm cache clean --force || echo "NPM cache clean failed, continuing..."

    # Show disk space after cleanup
    echo "üíæ Checking disk space after cleanup:"
    df -h /

initialize_database:
  stage: post-deploy
  tags:
    - shell
  needs:
    - job: deploy_all
      optional: true # Make deploy_all optional to support skipping it
  variables:
    IS_DEPLOYMENT: 'true'
  rules:
    - if: $SKIP_DB_INIT == "true"
      when: never
    - if: $SKIP_DEPLOY == "true" && ($CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master")
      when: on_success # Run even if deploy was skipped
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"
      when: on_success
  # Add cache configuration to reuse node_modules from test_flow
  cache:
    key: ${CI_COMMIT_REF_SLUG}-fabric-binaries
    paths:
      - src/server/node_modules/
      - src/ledger/bin/
      - ~/.npm/
    policy: pull # Only need to pull, not push
  before_script:
    - |
      # Add disk usage monitoring
      echo "üíæ Checking disk space before job starts:"
      df -h /
      docker system df || echo "Docker not running or command failed"

      # On Amazon Linux, make sure curl is available
      if ! command -v curl &> /dev/null; then
        sudo yum install -y curl
        sudo yum clean all
      fi

      # Fix permissions for Prisma binaries more aggressively
      find ./src/server/node_modules/.bin -type f -exec chmod +x {} \; || true
      sudo find ./src/server/node_modules/.bin -type f -exec chmod 755 {} \; || true
      sudo chown -R gitlab-runner:gitlab-runner ./src/server/node_modules/.bin/ || true

      # Just verify versions of pre-installed tools
      node --version
      npm --version
  script:
    - cd $CI_PROJECT_DIR/src/server
    - npm install
    - |
      # Regenerate Prisma client with the correct environment variable
      echo "üîÑ Regenerating Prisma client..."
      npx --no-permission-request prisma generate

      # Export all the required environment variables from GitLab CI
      export POSTGRES_CONNECTION_URL=$POSTGRES_CONNECTION_URL
      # For backward compatibility during transition
      export DATABASE_URL=$POSTGRES_CONNECTION_URL
      export SUPABASE_API_URL=$SUPABASE_API_URL
      export SUPABASE_ANON_KEY=$SUPABASE_ANON_KEY
      export SUPABASE_SERVICE_ROLE_KEY=$SUPABASE_SERVICE_ROLE_KEY
      export FABRIC_CONNECTION=${FABRIC_CONNECTION:-network.legitifyapp.com}
      export RESOURCE_SERVER_PORT=${RESOURCE_SERVER_PORT:-8080}
      export FABRIC_CHANNEL=${FABRIC_CHANNEL:-legitifychannel}
      export FABRIC_CHAINCODE=${FABRIC_CHAINCODE:-degreeCC}
      export LEGITIFY_API_URL=${LEGITIFY_API_URL:-"https://api.legitifyapp.com"}

      # Show disk space before database operations
      echo "üíæ Checking disk space before database operations:"
      df -h /

      # Initialize database
      echo "üîÑ Initializing database on deployed backend..."
      npm run db:init

      sleep 60

      # Run test flow after database initialization
      echo "üß™ Running test flow after deployment and database initialization..."
      bash scripts/test-flow.sh || echo "‚ö†Ô∏è Test flow completed with warnings or errors"

      # Show disk space after operations
      echo "üíæ Checking disk space after operations:"
      df -h /
  after_script: |
    # Clean up after database initialization
    echo "Cleaning up after database initialization..."
    docker system prune -af --volumes || echo "Docker prune failed, continuing..."
    npm cache clean --force || echo "NPM cache clean failed, continuing..."
