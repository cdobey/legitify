image: node:18-bullseye

variables:
  SERVER_PID_FILE: "/tmp/server.pid"
  SERVER_STARTUP_TIMEOUT: 120
  TEST_FLOW_TIMEOUT: 300

test_flow:
  stage: test
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "master"
  tags:
    - shell
  before_script:
    - |
      sudo apt-get update && sudo apt-get install -y \
        curl \
        git \
        jq \
        docker.io \
        docker-compose \
        golang-go

    - |
      curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
      export NVM_DIR="$HOME/.nvm"
      [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
      nvm install 18
      nvm use 18
      npm install -g typescript ts-node

    - node --version
    - npm --version
    - docker --version
    - go version

    - cd $CI_PROJECT_DIR
    - git clean -fdx
    - sudo chown -R gitlab-runner:gitlab-runner .

  script:
    # Install and build steps for your server and ledger
    - cd $CI_PROJECT_DIR/src/server
    - npm ci
    - npm install -g ts-node typescript

    - cd $CI_PROJECT_DIR/src/ledger
    - export ARCH=amd64
    - export FABRIC_PATH=$PWD
    - export PATH=$PATH:$FABRIC_PATH/bin
    - bash ./install-fabric.sh --fabric-version 2.5.10 binary --ca-version 1.5.13
    - chmod +x bin/*

    - cd chaincode/degreeChaincode
    - GO111MODULE=on go mod vendor
    - cd $CI_PROJECT_DIR/src/ledger/legitify-network
    - bash scripts/stopNetwork.sh || true
    - bash scripts/startNetwork.sh
    - bash scripts/testDegreeChaincode.sh

    # Start backend server with proper waiting
    - |
      cd $CI_PROJECT_DIR/src/server
      chmod +x src/scripts/start-fresh-db.sh
      source src/scripts/start-fresh-db.sh

      echo "Waiting for server to be fully ready..."
      TIMEOUT=$SERVER_STARTUP_TIMEOUT
      while [ $TIMEOUT -gt 0 ]; do
        if curl --max-time 5 -s http://localhost:3001/docs > /dev/null; then
          echo "Server is responding to requests"
          sleep 10  # Extra wait time for full initialization
          break
        fi
        echo "Waiting... ($TIMEOUT seconds remaining)"
        sleep 1
        TIMEOUT=$((TIMEOUT - 1))
      done

      if [ $TIMEOUT -eq 0 ]; then
        echo "Server failed to start within timeout period"
        exit 1
      fi

    # Run test flow with proper completion checking
    - |
      cd $CI_PROJECT_DIR/src/server

      # Use an absolute path for the marker file
      MARKER_FILE="$CI_PROJECT_DIR/src/server/test_flow_running"
      touch "$MARKER_FILE"

      # Run test flow in the foreground with output captured to a log file
      chmod +x scripts/test-flow.sh
      ./scripts/test-flow.sh > test_output.log 2>&1
      TEST_EXIT_CODE=$?

      # Remove the marker file to indicate that test flow has finished
      rm -f "$MARKER_FILE"

      # Display the complete output
      cat test_output.log

      # Verify that the test-flow script exited with success and printed the unique final message
      if [ $TEST_EXIT_CODE -ne 0 ] || ! grep -q "### ALL_TEST_FLOW_OPERATIONS_COMPLETED ###" test_output.log; then
        echo "Test flow failed or did not complete successfully"
        exit 1
      fi

      # Additional verification that all expected operations completed
      expected_patterns=(
        "University registered with ID:"
        "Individual registered with ID:"
        "Employer registered with ID:"
        "University logged in"
        "Individual logged in"
        "Employer logged in"
        "Degree issued with ID:"
        "Degree acceptance response:"
        "Access requested with ID:"
        "Access grant response:"
        "Verification response:"
      )

      echo "Verifying all operations completed..."
      for pattern in "${expected_patterns[@]}"; do
        if ! grep -q "$pattern" test_output.log; then
          echo "Missing expected operation: $pattern"
          exit 1
        fi
      done

      echo "All test flow operations completed successfully"

  after_script:
    - |
      if [ ! -f "$CI_PROJECT_DIR/src/server/test_flow_running" ]; then
        echo "Starting cleanup..."
        set +e
        
        # Kill server process if it exists
        if [ -f "$SERVER_PID_FILE" ]; then
          kill -9 $(cat "$SERVER_PID_FILE") 2>/dev/null || true
          rm -f "$SERVER_PID_FILE"
        fi

        # Clean up database and wallet
        cd $CI_PROJECT_DIR/src/server || true
        docker-compose down -v || true
        sudo rm -rf pgdata src/wallet/* || true

        # Tear down Fabric network
        cd $CI_PROJECT_DIR/src/ledger/legitify-network || true
        ./network.sh down || true
        docker system prune -af --volumes || true

        # Reset permissions
        cd $CI_PROJECT_DIR || true
        sudo chown -R gitlab-runner:gitlab-runner . || true
        sudo find . -type d -exec chmod 755 {} + || true
        sudo find . -type f -exec chmod 644 {} + || true

        echo "Cleanup completed"
      else
        echo "Test flow is still running, skipping cleanup"
        exit 1
      fi

  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - src/server/node_modules/
      - ~/.npm/
    policy: pull-push
